{
    "docs": [
        {
            "location": "/",
            "text": "TestEZ is a BDD-style testing framework for Roblox Lua.\n\n\nWe use TestEZ at Roblox for testing our apps, in-game core scripts, built-in Roblox Studio plugins, as well as libraries like \nRoact\n and \nRodux\n.\n\n\nIt provides an API that can run all of your tests with a single method call as well as a more granular API that exposes each step of the pipeline.",
            "title": "Home"
        },
        {
            "location": "/getting-started/installation/",
            "text": "In the future, TestEZ will have pre-built model files for use within Roblox without other tools.\n\n\nMethod 1: Rojo (Roblox)\n\u00b6\n\n\n\n\nCopy the \nlib\n directory into your codebase\n\n\nRename the folder to \nTestEZ\n\n\nUse \nRojo\n to sync the files into a place\n\n\n\n\nMethod 2: Lemur (CI Systems)\n\u00b6\n\n\nYou can use \nLemur\n paired together with a regular Lua 5.1 interpreter to run tests written with TestEZ.\n\n\nThis is the best approach when testing Roblox Lua libraries using existing continuous integration systems like Travis-CI. We use this technique to run tests for \nRodux\n and other libraries.",
            "title": "Installation"
        },
        {
            "location": "/getting-started/installation/#method-1-rojo-roblox",
            "text": "Copy the  lib  directory into your codebase  Rename the folder to  TestEZ  Use  Rojo  to sync the files into a place",
            "title": "Method 1: Rojo (Roblox)"
        },
        {
            "location": "/getting-started/installation/#method-2-lemur-ci-systems",
            "text": "You can use  Lemur  paired together with a regular Lua 5.1 interpreter to run tests written with TestEZ.  This is the best approach when testing Roblox Lua libraries using existing continuous integration systems like Travis-CI. We use this technique to run tests for  Rodux  and other libraries.",
            "title": "Method 2: Lemur (CI Systems)"
        },
        {
            "location": "/getting-started/running-tests/",
            "text": "TestEZ provides a convenient method to run tests in a single pass:\n\n\nlocal\n \nTestEZ\n \n=\n \nrequire\n(\n<\npath\n \nto\n \nTestEZ\n>\n)\n\n\n\nTestEZ\n.\nTestBootstrap\n:\nrun\n(\nMY_TESTS\n)\n\n\n\n\n\nThe method also returns information about the test run that can be used to take further action!\n\n\nThe internals of TestEZ are being reworked, so accessing other APIs at this time isn't recommended.",
            "title": "Running Tests"
        },
        {
            "location": "/getting-started/writing-tests/",
            "text": "Create \n.spec.lua\n files (or Roblox objects with the \n.spec\n suffix) for each module you want to test. These modules should return a function that in turn calls functions from TestEZ.\n\n\nA simple module and associated TestEZ spec might look like:\n\n\nGreeter.lua\n\n\nlocal\n \nGreeter\n \n=\n \n{}\n\n\n\nfunction\n \nGreeter\n:\ngreet\n(\nperson\n)\n\n    \nreturn\n \n\"Hello, \"\n \n..\n \nperson\n\n\nend\n\n\n\nreturn\n \nGreeter\n\n\n\n\nGreeter.spec.lua\n\n\nreturn\n \nfunction\n()\n\n    \nlocal\n \nGreeter\n \n=\n \nrequire\n(\nscript\n.\nParent\n.\nGreeter\n)\n\n\n    \ndescribe\n(\n\"greet\"\n,\n \nfunction\n()\n\n        \nit\n(\n\"should include the customary English greeting\"\n,\n \nfunction\n()\n\n            \nlocal\n \ngreeting\n \n=\n \nGreeter\n:\ngreet\n(\n\"X\"\n)\n\n            \nexpect\n(\ngreeting\n:\nmatch\n(\n\"Hello\"\n)).\nto\n.\nbe\n.\nok\n()\n\n        \nend\n)\n\n\n        \nit\n(\n\"should include the person being greeted\"\n,\n \nfunction\n()\n\n            \nlocal\n \ngreeting\n \n=\n \nGreeter\n:\ngreet\n(\n\"Joe\"\n)\n\n            \nexpect\n(\ngreeting\n:\nmatch\n(\n\"Joe\"\n)).\nto\n.\nbe\n.\nok\n()\n\n        \nend\n)\n\n    \nend\n)\n\n\nend\n\n\n\n\nThe functions \ndescribe\n, \nit\n, and \nexpect\n are injected by TestEZ and automatically hook into the current testing context.\n\n\nEvery module is implicitly scoped according to its path, meaning the tree that the above test represents might be:\n\n\nLuaChat\n    Greeter\n        greet\n            [+] should include the customary English greeting\n            [+] should include the person being greeted",
            "title": "Writing Tests"
        },
        {
            "location": "/getting-started/debugging-tests/",
            "text": "Often during development, you'll want to only run the test that's concerned with the specific code you're working on.\n\n\nTestEZ provides the \nSKIP()\n and \nFOCUS()\n functions to either skip or focus the block that the call is contained in.\n\n\nThis mechanism does not work for \nit\n blocks; use \nitSKIP\n and \nitFOCUS\n instead. Code inside \nit\n blocks is not run until tests are executed, while \ndescribe\n blocks are run immediately to figure out what tests a project contains.\n\n\nFor example, you might want to run the tests targeting a specific method or two for a \nDateTime\n module:\n\n\nDateTime.spec.lua\n\n\nreturn\n \nfunction\n()\n\n    \ndescribe\n(\n\"new\"\n,\n \nfunction\n()\n\n        \nFOCUS\n()\n\n\n        \nit\n(\n\"does really important things\"\n,\n \nfunction\n()\n\n            \n-- This block will run!\n\n        \nend\n)\n\n    \nend\n)\n\n\n    \nitFOCUS\n(\n\"has all methods we expect\"\n,\n \nfunction\n()\n\n        \n-- Calling FOCUS() would be too late here, so we use itFOCUS instead.\n\n\n        \n-- This block will run, too\n\n    \nend\n)\n\n\n    \ndescribe\n(\n\"Format()\"\n,\n \nfunction\n()\n\n        \nit\n(\n\"formats things\"\n,\n \nfunction\n()\n\n            \n-- This block will never run!\n\n        \nend\n)\n\n    \nend\n)\n\n\nend\n\n\n\n\n\n\nWarning\n\n\nFOCUS\n and \nSKIP\n are intended exclusively for development. It's not recommended that tests containing these calls are checked into version contorl.\n\n\nFuture versions of TeztEZ will be able to detect this when running in a CI system and fail tests to prevent that from happening.",
            "title": "Debugging Tests"
        },
        {
            "location": "/api-reference/",
            "text": "Inside Tests\n\u00b6\n\n\ndescribe\n\u00b6\n\n\ndescribe(phrase, callback)\n\n\n\n\nThis function creates a new \ndescribe\n block. These blocks correspond to the \nthings\n that are being tested.\n\n\nPut \nit\n blocks inside of \ndescribe\n blocks to describe what behavior should be correct.\n\n\nFor example:\n\n\ndescribe\n(\n\"This cheese\"\n,\n \nfunction\n()\n\n    \nit\n(\n\"should be moldy\"\n,\n \nfunction\n()\n\n        \nexpect\n(\ncheese\n.\nmoldy\n).\nto\n.\nequal\n(\ntrue\n)\n\n    \nend\n)\n\n\nend\n)\n\n\n\n\n\nit\n\u00b6\n\n\nit(phrase, callback)\n\n\n\n\nThis function creates a new 'it' block. These blocks correspond to the \nbehaviors\n that should be expected of the thing you're testing.\n\n\nFor example:\n\n\nit\n(\n\"should add 1 and 1\"\n,\n \nfunction\n()\n\n    \nexpect\n(\n1\n \n+\n \n1\n).\nto\n.\nequal\n(\n2\n)\n\n\nend\n)\n\n\n\n\n\nitFOCUS and itSKIP\n\u00b6\n\n\nitFOCUS(phrase, callback)\nitSKIP(phrase, callback)\n\n\n\n\nThese methods are special versions of \nit\n that automatically mark the \nit\n block as \nfocused\n or \nskipped\n. They're necessary because \nFOCUS\n and \nSKIP\n can't be called inside \nit\n blocks!\n\n\nFOCUS\n\u00b6\n\n\nFOCUS()\n\n\n\n\nWhen called inside a \ndescribe\n block, \nFOCUS()\n marks that block as \nfocused\n. If there are any focused blocks inside your test tree, \nonly\n focused blocks will be executed, and all other tests will be skipped.\n\n\nWhen you're writing a new set of tests as part of a larger codebase, use \nFOCUS()\n while debugging them to reduce the amount of noise you need to scroll through.\n\n\nFor example:\n\n\ndescribe\n(\n\"Secret Feature X\"\n,\n \nfunction\n()\n\n    \nFOCUS\n()\n\n\n    \nit\n(\n\"should do something\"\n,\n \nfunction\n()\n\n    \nend\n)\n\n\nend\n)\n\n\n\ndescribe\n(\n\"Secret Feature Y\"\n,\n \nfunction\n()\n\n    \nit\n(\n\"should do nothing\"\n,\n \nfunction\n()\n\n        \n-- This code will not run!\n\n    \nend\n)\n\n\nend\n)\n\n\n\n\n\n\n\nNote\n\n\nFOCUS\n does not work inside an \nit\n block. The bodies of these blocks aren't executed until the tests run, which is too late to change which tests will run.\n\n\n\n\nSKIP\n\u00b6\n\n\nSKIP()\n\n\n\n\nThis function works similarly to \nFOCUS()\n, except instead of marking a block as \nfocused\n, it will mark a block as \nskipped\n, which stops any of the test assertions in the block from being executed.\n\n\n\n\nNote\n\n\nSKIP\n does not work inside an \nit\n block. The bodies of these blocks aren't executed until the tests run, which is too late to change which tests will run.\n\n\n\n\nexpect\n\u00b6\n\n\nexpect(value)\n\n\n\n\nCreates a new \nExpectation\n, used for testing the properties of the given value.\n\n\nExpectations are intended to be read like English assertions. These are all true:\n\n\n-- Equality\n\n\nexpect\n(\n1\n).\nto\n.\nequal\n(\n1\n)\n\n\nexpect\n(\n1\n).\nnever\n.\nto\n.\nequal\n(\n2\n)\n\n\n\n-- Nil checking\n\n\nexpect\n(\n1\n).\nto\n.\nbe\n.\nok\n()\n\n\nexpect\n(\nfalse\n).\nto\n.\nbe\n.\nok\n()\n\n\nexpect\n(\nnil\n).\nnever\n.\nto\n.\nbe\n.\nok\n()\n\n\n\n-- Type checking\n\n\nexpect\n(\n1\n).\nto\n.\nbe\n.\na\n(\n\"number\"\n)\n\n\nexpect\n(\nnewproxy\n(\ntrue\n)).\nto\n.\nbe\n.\na\n(\n\"userdata\"\n)\n\n\n\n-- Function throwing\n\n\nexpect\n(\nfunction\n()\n\n    \nerror\n(\n\"nope\"\n)\n\n\nend\n).\nto\n.\nthrow\n()\n\n\n\nexpect\n(\nfunction\n()\n\n    \n-- I don't throw!\n\n\nend\n).\nnever\n.\nto\n.\nthrow\n()",
            "title": "API Reference"
        },
        {
            "location": "/api-reference/#inside-tests",
            "text": "",
            "title": "Inside Tests"
        },
        {
            "location": "/api-reference/#describe",
            "text": "describe(phrase, callback)  This function creates a new  describe  block. These blocks correspond to the  things  that are being tested.  Put  it  blocks inside of  describe  blocks to describe what behavior should be correct.  For example:  describe ( \"This cheese\" ,   function () \n     it ( \"should be moldy\" ,   function () \n         expect ( cheese . moldy ). to . equal ( true ) \n     end )  end )",
            "title": "describe"
        },
        {
            "location": "/api-reference/#it",
            "text": "it(phrase, callback)  This function creates a new 'it' block. These blocks correspond to the  behaviors  that should be expected of the thing you're testing.  For example:  it ( \"should add 1 and 1\" ,   function () \n     expect ( 1   +   1 ). to . equal ( 2 )  end )",
            "title": "it"
        },
        {
            "location": "/api-reference/#itfocus-and-itskip",
            "text": "itFOCUS(phrase, callback)\nitSKIP(phrase, callback)  These methods are special versions of  it  that automatically mark the  it  block as  focused  or  skipped . They're necessary because  FOCUS  and  SKIP  can't be called inside  it  blocks!",
            "title": "itFOCUS and itSKIP"
        },
        {
            "location": "/api-reference/#focus",
            "text": "FOCUS()  When called inside a  describe  block,  FOCUS()  marks that block as  focused . If there are any focused blocks inside your test tree,  only  focused blocks will be executed, and all other tests will be skipped.  When you're writing a new set of tests as part of a larger codebase, use  FOCUS()  while debugging them to reduce the amount of noise you need to scroll through.  For example:  describe ( \"Secret Feature X\" ,   function () \n     FOCUS () \n\n     it ( \"should do something\" ,   function () \n     end )  end )  describe ( \"Secret Feature Y\" ,   function () \n     it ( \"should do nothing\" ,   function () \n         -- This code will not run! \n     end )  end )    Note  FOCUS  does not work inside an  it  block. The bodies of these blocks aren't executed until the tests run, which is too late to change which tests will run.",
            "title": "FOCUS"
        },
        {
            "location": "/api-reference/#skip",
            "text": "SKIP()  This function works similarly to  FOCUS() , except instead of marking a block as  focused , it will mark a block as  skipped , which stops any of the test assertions in the block from being executed.   Note  SKIP  does not work inside an  it  block. The bodies of these blocks aren't executed until the tests run, which is too late to change which tests will run.",
            "title": "SKIP"
        },
        {
            "location": "/api-reference/#expect",
            "text": "expect(value)  Creates a new  Expectation , used for testing the properties of the given value.  Expectations are intended to be read like English assertions. These are all true:  -- Equality  expect ( 1 ). to . equal ( 1 )  expect ( 1 ). never . to . equal ( 2 )  -- Nil checking  expect ( 1 ). to . be . ok ()  expect ( false ). to . be . ok ()  expect ( nil ). never . to . be . ok ()  -- Type checking  expect ( 1 ). to . be . a ( \"number\" )  expect ( newproxy ( true )). to . be . a ( \"userdata\" )  -- Function throwing  expect ( function () \n     error ( \"nope\" )  end ). to . throw ()  expect ( function () \n     -- I don't throw!  end ). never . to . throw ()",
            "title": "expect"
        }
    ]
}